# 📚 정렬 알고리즘 📚

## 프로젝트 목적
***

본 프로젝트의 목적은 다양한 **정렬 알고리즘**에 대해서 성능 분석을 진행하는 것이다. 여기서 성능 분석이라함은, **입력 개수/정렬 정도**에 변화를 주었을때, 각 정렬 알고리즘이 얼마만큼의 실행 시간, 즉 **시간 복잡도**를 보여주느냐를 분석해본다. 따라서, 정렬 알고리즘 자체에는 크게 포커스를 두지 않았다.

### **입력 범위 및 종류**
입력 개수의 범위는 다음과 같다.
> 32 (2^5) ~ 1,048,576 (2^20)
- 다만 2의 모든 거듭제곱에 대해 그래프를 그리면 너무 데이터가 방대해지기에 2의 5승의 거듭제곱 꼴로 성능을 분석하였다. (2^5, 2^10, 2^15, 2^20)

입력의 정렬 정도의 종류는 다음과 같다. 이 프로젝트에서는 오름차순 정렬을 기준으로 성능을 분석한다. 
- <mark>최선(Best):</mark> 이미 완벽히 정렬된 상태
> ex) 1 2 3 4 5 6 7 ...
- <mark>중간 또는 평균(Average):</mark> 어느 정도만 정렬된 상태
> ex) 1 3 2 2 7 6 4 ...
- <mark>최악(Worst):</mark> 역순으로 정렬된 상태(내림차순 정렬)
> ex) 7 6 5 4 3 2 1 ...

### **프로그램 입출력**
* 입력: **입력 개수(n)** 를 받는다.

* 출력: 정렬 알고리즘을 실행하는데 **소요된 시간**을 출력한다.

## 프로그램 설명
*** 

### **정렬도 변경 방법**
입력 개수 n을 받으면, 최선, 평균, 최악 각 경우로 `vector`또는 `array`를 정렬도를 다르게 설정하고 소요 시간을 출력한다.

ex) 입력 개수 1024를 받고, vector<int> a(1024)를 선언한뒤, 
1. 최선(Best) - 오름차순 `vector` 선언
```c++
for(int i=0; i<n; i++)
    a[i] = i;
```
2. 평균(Average) - 랜덤 값이 들어간 `vector` 선언
```c++
srand(time(NULL));
for(int i=0; i<n; i++)
    a[i] = rand() % 1000000;
```
3. 최악(Worst) - 내림차순 `vector` 선언
```c++
for(int i=0; i<n; i++)
    a[i] = 1000000-i;
```

입력에 대한 변수값은 이제 조절할 수 있고, 문제는 실행 시간을 어떻게 계산하는가이다. 이는 `clock()`함수를 통해 해결 가능하다. 

### **실행 시간 계산 - Clock()**

함수 `clock()`은 `<time.h>` 헤더파일에 다음과 같이 정의되어있다.
> clock_t clock(void); 

`clock`이란 무엇인가?

디지털 회로 내에서 `clock`은 주어진 일을 순서대로 정확한 시간에 처리하기 위해 사용된다. `clock`은 시계의 역할을 하며, 일정한 시간간격으로 0과 1의 값이 번갈아 나타난다. **카운터**는 이 클록을 세는 역할을 한다. 

`clock`이 하나 발생 (0과 1이 한번 변경)할때마다 카운터가 1씩 증가한다. 즉, 이 주기성을 통해 컴퓨터가 시간을 측정하는 것이고, 이렇게 측정한 시간을 운영 체제에서 함수로 만들어 프로그래밍 언어에 제공 => `clock()` 함수.

![first](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/clock.png?raw=true)

함수를 살펴보면, `clock`함수는 `clock_t`라는 값을 반환하는데 이 값은 **CPU가 사용된 값**을 나타낸다. 정확히는 시간이 아닌 **clock수**를 반환하는것. 초 단위로 구하려면 초당 클록수를 알아야하는데 아래의 매크로를 사용한다.

> CLOCKS_PER_SEC

이처럼 초 단위 시간으로 바꾸기 위해 `CLOCKS_PER_SEC`라는 매크로로 나누어서 초단위로 구할 수 있다.

### **Clock() 적용 방법**
즉 clock_t 변수 `st`에 정렬 알고리즘 실행 전 clock() 함수로 클록수를 저장하고, 정렬 알고리즘 실행 후 변수 `en`에 clock() 함수로 클록수를 저장하여 두 변수의 차를 `CLOCKS_PER_SEC`로 나눠주면 그게 바로 정렬 알고리즘의 **실행 시간**이다. 보다 자세한 결과를 얻기 위해 `double` 자료형을 사용했다. 

## 정렬 알고리즘별 성능 분석
***

### **1. 버블 정렬 - Bubble sort**

알고리즘: 
* 이웃하는 숫자끼리 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬 - 이웃된 페어가 마치 **거품**을 연상시켜 이를 비교하며 이동해서 `bubble`이다.

성능: 

![first](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/bubble.png?raw=true)

관찰 결과:

- 최선, 중간, 최악에 관계없이 입력 개수가 늘어날수록 기하급수적으로 실행 시간이 증가되고있다. 

- 다만 최선, 중간, 최악 순으로 시간이 짧은데, 그 이유는 버블 정렬 특성 상 이웃 항의 대소를 비교하는 연산이 무조건 수행되고, 최선은 이미 정렬되었기에 교환 연산이 없는 반면 중간이나 최악은 교환 연산이 추가로 많이 일어나기 때문이다. 

- 그래도 결국 정렬 상태에 관계없이 알고리즘은 이중 루프를 돌고 있으므로 **O(n^2)** 의 알고리즘이다.

- 사실 2^15까지도 시간이 차이가 나는데 2^20의 실행 시간이 너무 커져서 그 전 데이터가 거의 보이지 않는다.

| `Bubble sort`  | 최선 | 중간 | 최악 | 
|---|---|---|---|
| **시간복잡도** | O(n^2) | O(n^2) | O(n^2) |

### **2. 선택 정렬 - Selection sort**

알고리즘: 
* 입력중에서 매번 최솟값을 선택하여 가장 앞 원소와 자리를 바꿔가며 정렬 - 매번 최솟값을 **선택**하며 정렬해나가서 `selection`이다.

성능: 

![second](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/selection.png?raw=true)

관찰 결과:

- 최선, 중간, 최악에 관계없이 입력 개수가 늘어날수록 기하급수적으로 실행 시간이 증가되고있다. 

- 다만 최선, 중간, 최악 순으로 시간이 짧은데, 그 이유는 선택 정렬 특성 상 매 수행마다 최솟값을 비교하는 연산이 무조건 수행되고, 최선은 이미 정렬되었기에 최솟값 갱신 연산이 없는 반면 중간이나 최악은 최솟값 갱신 연산이 추가로 많이 일어나기 때문이다. 

- 버블 정렬보다는 전체적인 시간이 빠르다.

- 그래도 차이 시간은 미미하며, 결국 정렬 상태에 관계없이 알고리즘은 이중 루프를 돌고 있으므로 **O(n^2)** 의 알고리즘이다.

| `Selection sort`  | 최선 | 중간 | 최악 | 
|---|---|---|---|
| **시간복잡도** | O(n^2) | O(n^2) | O(n^2) |

### **3. 삽입 정렬 - Insertion sort**

알고리즘: 
* 정렬된 부분(앞부분)과 그렇지 않은 부분(뒷부분)으로 나누어 뒷부분의 가장 왼쪽 원소를 앞부분 중 적절한 위치로 삽입하며 정렬 - 적절한 위치(앞자리는 작은 원소, 뒷자리는 큰 원소)에 **삽입**하며 정렬해나가서 `insertion`이다.

성능: 

![third](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/insertion.png?raw=true)

관찰 결과:

- 버블이나 선택과는 다른 양상을 보인다. 특히, 최선일 경우에는 **O(n)** 을 보장한다. 그 이유는, 이미 정렬된 상태에는 각 원소들이 이미 **적절한 위치**에 있으므로 삽입을 할 필요가 없기 때문이다. 다만 이 여부를 알아보기 위해 각 원소를 한번씩은 다 탐색하기에 **O(n)** 이 걸린다.

- 중간, 최악 순으로 시간이 짧은데, 그 이유는 알고리즘 특성 상 중간은 중간 정도에서 삽입 위치를 찾을것이고, 최악의 경우는 매번 가장 왼쪽까지 이동을 하고 삽입을 하기 때문이다. 

- 결국 최선일때는 **O(n)** , 나머지 경우에는 알고리즘이 이중 루프를 돌고 있으므로 **O(n^2)** 의 알고리즘이다.

| `Insertion sort`  | 최선 | 중간 | 최악 | 
|---|---|---|---|
| **시간복잡도** | O(n) | O(n^2) | O(n^2) |

### **4. 쉘 정렬 - Shell sort**

알고리즘: 
*  - 버블이나 삽입 정렬은 원소를 교환하거나 원소를 적절한 위치에 삽입시키기 위해 한칸씩 이동한다. 이 속도를 빠르게 하기 위해 뒷부분의 작은 숫자는 빠르게 앞으로 이동시키고, 앞부분의 큰 숫자는 뒷부분으로 이동시킨 후, 삽입 정렬을 수행한다. - 고안자가 `Donald Shell`이기에 `Shell`로 이름붙여졌다.

성능: 

![fourth](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/shell.png?raw=true)

관찰 결과:

- 최선, 최악, 중간순으로 시간이 짧긴한데 이게 항상 성립한다고 단정지을 수 없다. 왜냐하면 쉘 정렬의 핵심은 입력에 얼마나 적절한 `gap`을 설정하냐이기 때문이다. 또한 중간의 경우도 충분히 많은 테스트 케이스를 돌려본게 아니기에 이 순서가 항상 맞는건 아니다.

- 그래도 버블, 선택, 삽입 정렬에 비하면 매우 시간이 빨라졌다.

- 삽입 정렬을 기반으로 한 알고리즘이다 보니 최선일때는 **O(n)** , 나머지 경우에는 `gap`의 설정에따라 다르겠지만 평균적으로 **O(n^1.25)** 의 알고리즘이다.

| `Shell sort`  | 최선 | 중간 | 최악 | 
|---|---|---|---|
| **시간복잡도** | O(n) | O(n^1.25) | O(n^1.25) |

### **5. 힙 정렬 - Heap sort**

알고리즘: 
- **힙(Heap)** 을 사용하는 정렬이기에 `Heap`이다. 힙은 힙 조건을 만족하는 완전 이진트리이며, 이때 힙 조건은 각 노드의 값이 자식 노드의 값보다 커야 함(Max-Heap)을 일컫는다.

성능: 

![fifth](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/heap.png?raw=true)

관찰 결과:

- 최선, 중간, 최악 상관없이 거의 비슷한 성능을 보인다. 어차피 힙을 만드는데에 동일하게 O(n)이 걸리고 최악의 경우가 힙의 가장 아래층까지 내려가며 교환할 때인데 이 높이는 최대 `log n`이기에 결국 비슷한 성능을 보인다.

- 힙 정렬 역시 성능 시간이 좋은 알고리즘에 속한다. 2^20승의 입력 연산까지 무리없이 1초 내에 소화한다.

- 다룬 6개의 정렬중 최선, 중간, 최악의 평균 성능을 내보면 종합적으로 가장 좋은 성능을 보였다.

| `Heap sort`  | 최선 | 중간 | 최악 | 
|---|---|---|---|
| **시간복잡도** | O(n log n) | O(n log n) | O(n log n) |

### **6. 퀵 정렬 - Quick sort**

알고리즘: 
- `pivot`을 정해 왼쪽에는 작은 숫자들, 오른쪽에는 큰 숫자를 배분하며 분할정복 해나간다. 대표적으로 속도가 **빠른** 알고리즘으로 `quick`으로 불리운다.

성능: 

![sixth](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/quick.png?raw=true)

관찰 결과:

- 특이한 성능을 보인다. 평균일때는 오히려 가장 좋은 성능을 보이고, 최선/최악일때 선택, 삽입같은 **O(n^2)** 까지의 안좋은 성능을 보인다. 이 이유는 `pivot`의 선정이다. `pivot`이 정확하게 이등분(왼쪽에 작은 숫자들, 오른쪽에 큰 숫자들)해야, 즉 균등하게 나눠야 빠르게 분할정복이 이루어지는데 최선이나 최악에서는 최솟값 또는 최댓값을 `pivot`으로 설정하니 그렇지 못하는 것이다. **즉 매 분할마다 하나의 원소밖에 정렬하지 못한다.**

- 그래도 랜덤(평균)으로 주어진 입력, 즉 어떻게 보면 가장 일반적인 입력에서는 가장 빠른 속도를 보였다. (2^20 실행 시간 -> 0.261초)

| `Quick sort`  | 최선 | 중간 | 최악 | 
|---|---|---|---|
| **시간복잡도** | O(n^2) | O(n log n) | O(n^2) |

## 제한 사항 및 개선점
***

* 최선이나 최악의 경우는 유일 경우이기 때문에 그렇다쳐도 평균 경우를 다룬 데이터가 살짝 신뢰도가 떨어진다. 왜냐하면 충분히 많은 횟수를 돌려보며 평균에 대한 성능을 측정한게 아니라 몇번의 시도로 그쳤기 때문이다. 이를 보완하면 평균 입력에 대한 좀 더 정확한 성능을 측정할 수 있을것이다.

* 입력 개수가 커질수록 실행 시간이 기하급수적으로 늘어나는 알고리즘(O(n^2) 알고리즘)에서 적은 입력에 대한 데이터가 그래프에서 알아보기 힘든게 아쉽다. 2의 5승, 10승 등에서도 분명히 성능 차이가 나타나는데 나중에 큰 데이터 2의 15승, 2의 20승이 들어오면 값 차이가 너무커져 한 그래프에 나타내려면 어쩔 수 없이 그 전 값이 거의 무시되는 수준이다. 이를 개선하기 위해 조금 더 입력 개수를 세분화하여 보다 연속적인 그래프를 그려보면 더욱 더 디테일한 성능 분석이 될것이다.

* 매우 다양한 정렬 알고리즘에서 6개밖에 다뤄보지 못한게 아쉽다. 기회가 되면 병합, 기수, 카운팅 정렬 등 다른 정렬들도 성능 분석을 해보고 싶다.

<br>

<p align="center">Copyrightⓒ. 2022. By Seonghwan Shin. </p>
<p align="center">All Rights Reserved.</p>
<p align="center">-The End-</p>












