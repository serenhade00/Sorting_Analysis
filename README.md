# 📚 정렬 알고리즘 📚

## 프로젝트 목적
***

본 프로젝트의 목적은 다양한 **정렬 알고리즘**에 대해서 성능 분석을 진행하는 것이다. 여기서 성능 분석이라함은, **입력 개수/정렬 정도**에 변화를 주었을때, 각 정렬 알고리즘이 얼마만큼의 실행 시간, 즉 **시간 복잡도**를 보여주느냐를 분석해본다.

### **입력 범위 및 종류**
입력 개수의 범위는 다음과 같다.
> 32 (2^5) ~ 1,048,576 (2^20)
- 다만 2의 모든 거듭제곱에 대해 그래프를 그리면 너무 데이터가 방대해지기에 2의 5승의 거듭제곱 꼴로 성능을 분석하였다. (2^5, 2^10, 2^15, 2^20)

입력의 정렬 정도의 종류는 다음과 같다. 이 프로젝트에서는 오름차순 정렬을 기준으로 성능을 분석한다. 
- <mark>최선(Best):</mark> 이미 완벽히 정렬된 상태
> ex) 1 2 3 4 5 6 7 ...
- <mark>중간 또는 평균(Average):</mark> 어느 정도만 정렬된 상태
> ex) 1 3 2 2 7 6 4 ...
- <mark>최악(Worst):</mark> 역순으로 정렬된 상태(내림차순 정렬)
> ex) 7 6 5 4 3 2 1 ...

### **프로그램 입출력**
* 입력: **입력 개수(n)** 를 받는다.

* 출력: 정렬 알고리즘을 실행하는데 **소요된 시간**을 출력한다.

## 프로그램 설명
*** 

### **정렬도 변경 방법**
입력 개수 n을 받으면, 최선, 평균, 최악 각 경우로 `vector`또는 `array`를 정렬도를 다르게 설정하고 소요 시간을 출력한다.

ex) 입력 개수 1024를 받고, vector<int> a(1024)를 선언한뒤, 
1. 최선(Best) - 오름차순 `vector` 선언
```c++
for(int i=0; i<n; i++)
    a[i] = i;
```
2. 평균(Average) - 랜덤 값이 들어간 `vector` 선언
```c++
srand(time(NULL));
for(int i=0; i<n; i++)
    a[i] = rand() % 1000000;
```
3. 최악(Worst) - 내림차순 `vector` 선언
```c++
for(int i=0; i<n; i++)
    a[i] = 1000000-i;
```

입력에 대한 변수값은 이제 조절할 수 있고, 문제는 실행 시간을 어떻게 계산하는가이다. 이는 `clock()`함수를 통해 해결 가능하다. 

### **실행 시간 계산 - Clock()**

함수 `clock()`은 `<time.h>` 헤더파일에 다음과 같이 정의되어있다.
> clock_t clock(void); 

`clock`이란 무엇인가?

디지털 회로 내에서 `clock`은 주어진 일을 순서대로 정확한 시간에 처리하기 위해 사용된다. `clock`은 시계의 역할을 하며, 일정한 시간간격으로 0과 1의 값이 번갈아 나타난다. **카운터**는 이 클록을 세는 역할을 한다. 

`clock`이 하나 발생 (0과 1이 한번 변경)할때마다 카운터가 1씩 증가한다. 즉, 이 주기성을 통해 컴퓨터가 시간을 측정하는 것이고, 이렇게 측정한 시간을 운영 체제에서 함수로 만들어 프로그래밍 언어에 제공 => `clock()` 함수.

![first](https://github.com/serenhade00/Sorting_Analysis/blob/main/img/clock.png?raw=true)

함수를 살펴보면, `clock`함수는 `clock_t`라는 값을 반환하는데 이 값은 **CPU가 사용된 값**을 나타낸다. 정확히는 시간이 아닌 **clock수**를 반환하는것. 초 단위로 구하려면 초당 클록수를 알아야하는데 아래의 매크로를 사용한다.

> CLOCKS_PER_SEC

이처럼 초 단위 시간으로 바꾸기 위해 `CLOCKS_PER_SEC`라는 매크로로 나누어서 초단위로 구할 수 있다.

### **Clock() 적용 방법**
즉 clock_t 변수 `st`에 정렬 알고리즘 실행 전 clock() 함수로 클록수를 저장하고, 정렬 알고리즘 실행 후 변수 `en`에 clock() 함수로 클록수를 저장하여 두 변수의 차를 `CLOCKS_PER_SEC`로 나눠주면 그게 바로 정렬 알고리즘의 **실행 시간**이다.

## 정렬 알고리즘별 성능 분석
***





